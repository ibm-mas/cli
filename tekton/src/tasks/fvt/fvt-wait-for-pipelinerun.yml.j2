---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: mas-fvt-wait-for-pipelinerun
spec:
  params:
    - name: pipelinerun_name
      type: string
    - name: ignore_failure
      type: string
      default: "True"
    - name: remote_ocp_cluster
      type: string
      default: ""
    - name: remote_ocp_type
      type: string
      default: ""
    - name: remote_ibmcloud_api_key
      type: string
      default: ""
    - name: remote_rosa_token
      type: string
      default: ""
    - name: remote_rosa_cluster_admin_password
      type: string
      default: ""
    - name: aws_region
      type: string
      default: ""
    - name: aws_secret_access_key
      type: string
      default: ""
    - name: aws_access_key_id
      type: string
      default: ""
    - name: argocd_remove_deny_window
      type: string
      default: "False"
  stepTemplate:
    name: wait-for-pipelinerun
    env:
      - name: REMOTE_OCP_CLUSTER
        value: $(params.remote_ocp_cluster)
      - name: ARGOCD_REMOVE_DENY_WINDOW
        value: $(params.argocd_remove_deny_window)
  steps:
    - name: wait-for-pipelinerun
      imagePullPolicy: Always
      image: quay.io/ibmmas/cli:7.7.0-pre.gitops
      script: |
        #!/usr/bin/env bash

        if [ ! -z $REMOTE_OCP_CLUSTER ];then
          echo "Logging into $(params.remote_ocp_cluster)"
          export CLUSTER_NAME=$(params.remote_ocp_cluster)
          export CLUSTER_TYPE=$(params.remote_ocp_type)
          export IBMCLOUD_APIKEY=$(params.remote_ibmcloud_api_key)
          export ROSA_TOKEN=$(params.remote_rosa_token)
          export ROSA_CLUSTER_ADMIN_PASSWORD=$(params.remote_rosa_cluster_admin_password)

          if [ $CLUSTER_TYPE == 'rosa' ];then
            aws configure set aws_access_key_id $(params.aws_access_key_id)
            aws configure set aws_secret_access_key $(params.aws_secret_access_key)
            aws configure set default.region $(params.aws_region)
          fi

          ROLE_NAME=ocp_login ansible-playbook ibm.mas_devops.run_role 
          OC_RC=$?
          if [ $OC_RC -ne 0 ]; then
            echo "oc login failed to $(params.remote_ocp_cluster)"
            exit 1
          fi
        fi
        
        echo "Waiting for pipelinerun/$(params.pipelinerun_name) in $(context.taskRun.namespace) to complete ..."

        echo ""
        echo "Status of pipelinerun"
        echo "------------------------------------------------------------------"
        oc -n $(context.taskRun.namespace) get pipelinerun/$(params.pipelinerun_name)

        echo ""
        echo "Waiting for pipelinerun/$(params.pipelinerun_name) to complete"
        echo "------------------------------------------------------------------"
        # oc -n $(context.taskRun.namespace) wait pipelinerun/$(params.pipelinerun_name) --for=condition=Succeeded --timeout=24h

        IGNORE_FAILURE=$(params.ignore_failure)
        PIPELINERUN_NAME=$(params.pipelinerun_name)
        COMPLETION_TIME=$(oc -n $(context.taskRun.namespace) get pipelinerun/$PIPELINERUN_NAME -o jsonpath='{.status.completionTime}')
        # 2 minutes * 720 = ~24 hours
        MAX_RETRIES=720
        RETRIES_USED=0
        DELAY=120
        while [[ "$COMPLETION_TIME" == "" && "$RETRIES_USED" -lt "$MAX_RETRIES" ]]; do
          echo "[$RETRIES_USED/$MAX_RETRIES] pipelinerun/$PIPELINERUN_NAME is still running.  Waiting $DELAY seconds before checking again"
          sleep $DELAY
          COMPLETION_TIME=$(oc -n $(context.taskRun.namespace) get pipelinerun/$PIPELINERUN_NAME -o jsonpath='{.status.completionTime}')
          RETRIES_USED=$((RETRIES_USED + 1))
        done

        echo "Completion Time = $COMPLETION_TIME"
        echo "Retries Used    = $RETRIES_USED"
        RESULT=$(oc -n $(context.taskRun.namespace) get pipelinerun/$PIPELINERUN_NAME -o jsonpath='{.status.conditions[0].status}')

        if [[ "$ARGOCD_REMOVE_DENY_WINDOW" == "True" ]]; then
          echo "Deleting ArgoCD sync window after FVT tests have completed"
          if [ -z $ARGOCD_URL ] || [ -z $ARGOCD_USERNAME ] || [ -z $ARGOCD_PASSWORD ]; then
            export ARGOCD_URL=$(oc get route  openshift-gitops-server -n openshift-gitops -ojsonpath='{.spec.host}')
            export ARGOCD_USERNAME=admin
            export ARGOCD_PASSWORD=$(oc get secret openshift-gitops-cluster -n openshift-gitops -ojsonpath='{.data.admin\.password}' | base64 -d ; echo)
          fi
          echo "argo:argocd login : ARGOCD_URL=$ARGOCD_URL ARGOCD_USERNAME=$ARGOCD_USERNAME ARGOCD_PASSWORD=${ARGOCD_PASSWORD:0:8}<snip> ..."
          argocd login $ARGOCD_URL --username $ARGOCD_USERNAME --password $ARGOCD_PASSWORD --insecure
          echo "argo:argocd proj window delete $MAS_INSTANCE_ID 0"
          argocd proj windows delete $MAS_INSTANCE_ID 0
        fi

        if [[ "$RESULT" == "True" ]]; then
          echo "Result          = PipelineRun completed successfully"
          exit 0
        elif [[ "$IGNORE_FAILURE" == "True" ]]; then
          echo "Result          = PipelineRun failed (ignored)"
          exit 0
        else
          echo "Result          = PipelineRun failed"
          exit 1
        fi
