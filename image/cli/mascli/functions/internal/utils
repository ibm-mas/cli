#!/bin/bash

COLOR_RED=`tput setaf 1`
COLOR_GREEN=`tput setaf 2`
COLOR_YELLOW=`tput setaf 3`
COLOR_BLUE=`tput setaf 4`
COLOR_MAGENTA=`tput setaf 5`
COLOR_CYAN=`tput setaf 6`

TEXT_BOLD=$(tput bold)
TEXT_DIM=$(tput dim)
TEXT_UNDERLINE=$(tput smul)
TEXT_RESET=$(tput sgr0)

H2_COUNT=0
H3_COUNT=0

function reset_colors() {
  echo -ne "${TEXT_RESET}\033[1K"
}

function echo_h1() {
  echo -e "${TEXT_BOLD}${TEXT_UNDERLINE}${1}${TEXT_RESET}"

  echo -e "${1}" >> $LOGFILE
  echo "===============================================================================" >> $LOGFILE
}

function echo_h2() {
  msg=$1
  prefix=$2

  H2_COUNT=$(($H2_COUNT + 1))
  H3_COUNT=0
  echo
  echo -e "${prefix}${TEXT_UNDERLINE}${H2_COUNT}) ${msg}${TEXT_RESET}"

  echo >> $LOGFILE
  echo -e "${prefix}${H2_COUNT}) ${msg}" >> $LOGFILE
  echo "-------------------------------------------------------------------------------" >> $LOGFILE
}

function echo_h3() {
  msg=$1
  prefix=$2

  H3_COUNT=$(($H3_COUNT + 1))
  echo
  echo -e "${prefix}${TEXT_UNDERLINE}${H2_COUNT}.${H3_COUNT}) ${msg}${TEXT_RESET}"

  echo >> $LOGFILE
  echo -e "${prefix}${H2_COUNT}.${H3_COUNT}) ${msg}" >> $LOGFILE
  echo "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~" >> $LOGFILE
}

function echo_h4() {
  msg=$1
  prefix=$2
  echo -e "${prefix}${TEXT_UNDERLINE}${msg}${TEXT_RESET}"
  echo -e "${prefix}${msg}" >> $LOGFILE
  echo "~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~" >> $LOGFILE
}

function echo_warning() {
  echo -e "${COLOR_RED}$1${TEXT_RESET}"
  echo -e "WARNING: $1" >> $LOGFILE
}

function echo_highlight() {
  echo "${COLOR_CYAN}$1${TEXT_RESET}"
  echo -e "$1" >> $LOGFILE
}

function echo_green() {
  echo "${COLOR_GREEN}$1${TEXT_RESET}"
  echo -e "$1" >> $LOGFILE
}

function echo_blue() {
  echo "${COLOR_BLUE}$1${TEXT_RESET}"
  echo -e "$1" >> $LOGFILE
}

function echo_dim() {
  echo "${TEXT_DIM}$1${TEXT_RESET}"
  echo -e "$1" >> $LOGFILE
}

function echo_reset_dim() {
  echo "${TEXT_RESET}${TEXT_DIM}    $1"
  echo -e "$1" >> $LOGFILE
}

function echo_hr1() {
  echo "===============================================================================" | tee $LOGFILE
}

function echo_hr2() {
  echo "-------------------------------------------------------------------------------" | tee $LOGFILE
}


# Prompt for confirmation to continue
# -----------------------------------------------------------------------------
# Usage:
#  confirm "Do you want to continue" $SAVED_RESPONSE_FROM_LAST_TIME
#  confirm "Do you want to continue"
confirm() {
  prompt=$1
  default=$2
  if [[ "${default}" != "" ]]; then
    read -e -p "${COLOR_YELLOW}${prompt:-Proceed? [y/N]} ${COLOR_MAGENTA}" -i "${default}" response
  else
    read -p "${COLOR_YELLOW}${prompt:-Proceed? [y/N]} ${COLOR_MAGENTA}" response
  fi

  case "$response" in
    [yY][eE][sS]|[yY])
      export ALREADY_CONFIRMED="true"
      true
      ;;
    [nN][oO]|[nN])
      false
      ;;
    *)
      false
      ;;
  esac
}

confirm_default_yes() {
  read -r -p "${COLOR_YELLOW}${1:-Proceed? [Y/n]} ${COLOR_MAGENTA}" response
  case "$response" in
    [yY][eE][sS]|[yY])
      export ALREADY_CONFIRMED="true"
      true
      ;;
    [nN][oO]|[nN])
      export ALREADY_CONFIRMED="true"
      false
      ;;
    *)
      true
      ;;
  esac
}

function prompt_for_number(){
  msg=$1
  varname=$2
  # When override is set, the default provided in $3 will override the saved default
  override=$4

  if [[ -z "${!varname}" || "$override" == "override" ]]; then
    # Use the script default
    default=$3
  else
    # Use the saved default
    default=${!varname}
  fi

  while :; do

    if [[ "${default}" != "" ]]; then
      read -e -p "${COLOR_YELLOW}$msg ${COLOR_MAGENTA}> " -i "${default}" input
    else
      read -p "${COLOR_YELLOW}$msg ${COLOR_MAGENTA}> " input
    fi
    echo -ne "${TEXT_RESET}\033[1K"
    # https://stackoverflow.com/a/13717788
    re='^[1-9][0-9]*$'
    if [[ $input =~ $re ]] ; then
      break
    fi
  done
  printf -v "$varname" "%s" "$input"
}

function prompt_for_secret(){
  msg=$1
  varname=$2
  # When override is set, the default provided in $3 will override the saved default
  reuse_msg=$3

  # Use the saved default
  default=${!varname}

  if [[ "${default}" != "" && "${reuse_msg}" != "" ]]; then
    if ! confirm_default_yes "$reuse_msg [Y/n]"; then
      input=$(/bin/systemd-ask-password "${COLOR_YELLOW}$msg ${COLOR_MAGENTA}> ")
      echo -ne "${TEXT_RESET}\033[1K"
      # https://stackoverflow.com/a/13717788
      printf -v "$varname" "%s" "$input"
    fi
  else
    input=$(/bin/systemd-ask-password "${COLOR_YELLOW}$msg ${COLOR_MAGENTA}> ")
    echo -ne "${TEXT_RESET}\033[1K"
    # https://stackoverflow.com/a/13717788
    printf -v "$varname" "%s" "$input"
  fi
  echo -ne "${TEXT_RESET}\033[1K"
}


function prompt_for_input(){
  msg=$1
  varname=$2
  # When override is set, the default provided in $3 will override the saved default
  override=$4

  if [[ -z "${!varname}" || "$override" == "override" ]]; then
    # Use the script default
    default=$3
  else
    # Use the saved default
    default=${!varname}
  fi

  if [[ "${default}" != "" ]]; then
    read -e -p "${COLOR_YELLOW}$msg ${COLOR_MAGENTA}> " -i "${default}" input
  else
    read -p "${COLOR_YELLOW}$msg ${COLOR_MAGENTA}> " input
  fi
  echo -ne "${TEXT_RESET}\033[1K"
  # https://stackoverflow.com/a/13717788
  printf -v "$varname" "%s" "$input"
}

function check_project_exists(){
  varname=$1
  oc get "project/$varname" > /dev/null 2>&1

  if [ "$?" == "0" ]; then
    true
  else
    false
  fi
}

function prompt_for_confirm() {
  msg=$1
  varname=$2
  if [[ "$varname" != "" ]]; then
    if [[ "${!varname}" == "true" ]]; then
      default="y"
    elif [[ "${!varname}" == "false" ]]; then
      default="n"
    else
      default=""
    fi
  else
    default=""
  fi

  if confirm "${COLOR_YELLOW}$msg ${COLOR_MAGENTA}[y/N]" $default; then
    # Reset colours and clear the current line (\033[1K)
    echo -ne "${TEXT_RESET}\033[1K"
    # Set the variable named "$varname" to "true"
    if [[ "$varname" != "" ]]; then
      printf -v "$varname" "%s" "true"
    fi
    true
  else
    # Reset colours and clear the current line (\033[1K)
    echo -ne "${TEXT_RESET}\033[1K"
    # Set the variable named "$varname" to "false"
    if [[ "$varname" != "" ]]; then
      printf -v "$varname" "%s" "false"
    fi
    false
  fi
}

function prompt_for_confirm_default_yes() {
  msg=$1
  varname=$2
  if confirm_default_yes "${COLOR_YELLOW}$msg ${COLOR_MAGENTA}[Y/n]"; then
    # Reset colours and clear the current line (\033[1K)
    echo -ne "${TEXT_RESET}\033[1K"
    if [[ "$varname" != "" ]]; then
      printf -v "$varname" "%s" "true"
    fi
    true
  else
    # Reset colours and clear the current line (\033[1K)
    echo -ne "${TEXT_RESET}\033[1K"
    if [[ "$varname" != "" ]]; then
      printf -v "$varname" "%s" "false"
    fi
    false
  fi
}

function install_dependencies_ubuntu() {
  # APT package installations
  # python3-pip is required to install additional python packages
  # ansible is required for ansible-galaxy command to be available
  sudo apt install python3-pip ansible

  # Python package installations
  python3 -m pip install ansible junit_xml pymongo xmljson kubernetes==12.0.1 openshift==0.12.1

  # Confirm versions
  python3 --version
  ansible-playbook --version
}

function detect_airgap() {
  oc get ImageContentSourcePolicy ibm-mas-and-dependencies &> /dev/null
  if [[ "$?" == "0" ]]; then
    export AIRGAP_MODE=true
  else
    unset AIRGAP_MODE
  fi
}

# detect_sno function checks the number of nodes in the cluster. If there is only one node, then the cluster is an SNO
# For SNO, we have only one master node and zero worker nodes
# We check for the number of lines the command oc get nodes returns. If it is equal to 2, then the cluster is SNO
# The reason we check for 2 is that the first line is the heading. Following is an example of the output
#                        NAME                           STATUS   ROLES           AGE   VERSION
#                        ip-10-0-141-250.ec2.internal   Ready    master,worker   22h   v1.21.11+5cc9227
# when we run wc -l shell script command, wc gets the word count and -l gets the number of lines.
function detect_sno() {
  sno_num_nodes=$(oc get nodes | wc -l | xargs)
  if [[ "$sno_num_nodes" == "2" ]]; then
    export SNO_MODE=true
  else
    unset SNO_MODE
  fi
}


function ocp_version_check() {
  # TODO: Migrate this into python-devops
  # Check for OCP 4.9, 4.10, & 4.11
  export OCP_VERSION=$(oc get clusterversion version -o jsonpath="{.status.desired.version}")
  if [[ "$OCP_VERSION" =~ ^4\.9\.* ]] || [[ "$OCP_VERSION" =~ ^4\.10\.* ]] || [[ "$OCP_VERSION" =~ ^4\.11\.* ]]; then
    echo
    echo_warning "Warning: OpenShift Container Platform v${OCP_VERSION} detected!"
    echo_warning " - This version is now out of support by Red Hat and ${TEXT_UNDERLINE}not a supported platform for IBM Maximo Application Suite${TEXT_RESET}"
    echo_warning " - The installation of IBM Maximo Application Suite may not proceed, you must upgrade to at least OCP v4.12 before installing/updating/upgrading MAS"
    echo
    echo_warning "For more information refer to the Red Hat OpenShift Container Platform Life Cycle Policy:"
    echo "  ${COLOR_CYAN}${TEXT_UNDERLINE}https://access.redhat.com/support/policy/updates/openshift/${TEXT_RESET}"
    reset_colors
    exit 1
  fi
}

# Calls jinjanate with common arguments. Call jinjanate directly if this does not suit your use case.
function jinjanate_commmon() {
  local template_path=$1
  local output_path=$2
  local filter_files=$(ls $CLI_DIR/templates/filters/*.py)
  for file in $filter_files; do
    local filter_params="${filter_params} --filters ${file}"
  done
  if [ -n "$output_path" ]; then
    local output_opts="-o ${output_path}"
  fi
  # Get the directory of the template to use as searchpath for includes
  local template_dir=$(dirname "$template_path")
  jinjanate --quiet --undefined --searchpath "$template_dir" $filter_params $template_path $output_opts
}

#Get value from FILE at given DOTPATH
function get_tf_value() {
    local FILE="$1"
    local DOTPATH="$2"

    if [[ -z "$FILE" || -z "$DOTPATH" ]]; then
        echo "Usage: get_tf_value <file.tf> '<dot.path>'" >&2
        return 1
    fi

    echo "$FILE" >&2
    echo "$DOTPATH" >&2
    # Use the same python interpreter everywhere
    local PYTHON_BIN
    PYTHON_BIN=$(command -v python3)

    if [[ -z "$PYTHON_BIN" ]]; then
        echo "Error: python3 not found" >&2
        return 1
    fi

    # Install python-hcl2 if missing
    if ! $PYTHON_BIN -c "import hcl2" 2>/dev/null; then
        echo "python-hcl2 not found. Installing..." >&2
        $PYTHON_BIN -m pip install python-hcl2 >/dev/null
    fi

    # Run Python and print ONLY the value
    $PYTHON_BIN <<EOF
import hcl2
import re
import sys
import json

file_path = """$FILE"""
dot_path = """$DOTPATH"""   # <- triple-quoted to avoid ANY shell quoting issues

def load_hcl(path):
    with open(path, "r") as f:
        return hcl2.load(f)

def unwrap_singleton_lists(obj):
    if isinstance(obj, list) and len(obj) == 1:
        return unwrap_singleton_lists(obj[0])
    if isinstance(obj, dict):
        return {k: unwrap_singleton_lists(v) for k, v in obj.items()}
    return obj

def resolve_path(obj, path):
    # tokens: key, [0], ["key-with-dash"]
    tokens = re.findall(r'\w+|\[\d+\]|\[".*?"\]', path)

    value = obj
    for t in tokens:
        # list index
        if t.startswith("[") and t.endswith("]") and t[1:-1].isdigit():
            value = value[int(t[1:-1])]
        # quoted key
        elif t.startswith('["') and t.endswith('"]'):
            value = value[t[2:-2]]
        else:
            value = value[t]
    return value

data = unwrap_singleton_lists(load_hcl(file_path))

try:
    result = resolve_path(data, dot_path)
    if isinstance(result, (list, dict)):
        print(json.dumps(result))
    else:
        print(result)
except Exception as e:
    print(f"Error: {e}", file=sys.stderr)
    sys.exit(1)
EOF
}

# Create Terraform related common files
function create_common_files() {
  local cluster_dir=$1
  
  if [[ -z "$cluster_dir" ]]; then
    echo_warning "create_common_files: cluster directory path is required"
    return 1
  fi
  
  if [[ ! -d "$cluster_dir" ]]; then
    echo_warning "create_common_files: directory does not exist: $cluster_dir"
    return 1
  fi
  
  # Handle backend.tf with template
  if [[ ! -f "$cluster_dir/backend.tf" ]]; then
    echo "  Creating backend.tf from template"
    jinjanate_commmon "$CLI_DIR/templates/gitops/appset-configs/cluster/instance/ibm-iac-backend.yaml.j2" "$cluster_dir/backend.tf.json"
  else
    echo "  File already exists: backend.tf"
  fi
  
  # Handle provider.tf with template
  if [[ ! -f "$cluster_dir/provider.tf" ]]; then
    echo "  Creating provider.tf from template"
    jinjanate_commmon "$CLI_DIR/templates/gitops/appset-configs/cluster/instance/ibm-iac-provider.yaml.j2" "$cluster_dir/provider.tf"
  else
    echo "  File already exists: provider.tf"
  fi
  
  # Create other empty files if they don't exist
  local empty_tf_files=("terraform.tfvars" "variables.tf" "main.tf")
  
  for file in "${empty_tf_files[@]}"; do
    if [[ ! -f "$cluster_dir/$file" ]]; then
      echo "  Creating empty file: $file"
      touch "$cluster_dir/$file"
    else
      echo "  File already exists: $file"
    fi
  done
}

# -----------------------------------------------------------------------------
# Function: get_field
#
# Description:
#   Extracts and returns the Nth field from a given string using a specified
#   single-character delimiter.
#
# Parameters:
#   $1 - Input string to parse
#   $2 - Delimiter character (e.g. :, |, ,)
#   $3 - Field position to extract (1-based index)
#
# Returns:
#   Prints the extracted field to stdout.
#   Returns exit code 1 if input is invalid.
#
# Example:
#   arn="arn:aws:iam::1234567890:user/abcd"
#   account_id=$(get_field "$arn" ":" 5)
#   echo "$account_id"   # Output: 1234567890
# -----------------------------------------------------------------------------
get_field() {
  local input="$1"
  local delimiter="$2"
  local position="$3"

  if [[ -z "$input" || -z "$delimiter" || -z "$position" || ! "$position" =~ ^[0-9]+$ ]]; then
    echo "Usage: get_field <string> <delimiter> <position>" >&2
    return 1
  fi

  echo "$input" | cut -d"$delimiter" -f"$position"
}