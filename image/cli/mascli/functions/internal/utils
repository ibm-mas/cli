#!/bin/bash

COLOR_RED=`tput setaf 1`
COLOR_GREEN=`tput setaf 2`
COLOR_YELLOW=`tput setaf 3`
COLOR_BLUE=`tput setaf 4`
COLOR_MAGENTA=`tput setaf 5`
COLOR_CYAN=`tput setaf 6`

TEXT_BOLD=$(tput bold)
TEXT_DIM=$(tput dim)
TEXT_UNDERLINE=$(tput smul)
TEXT_RESET=$(tput sgr0)

H2_COUNT=0
H3_COUNT=0

function reset_colors() {
  echo -ne "${TEXT_RESET}\033[1K"
}

function echo_h1() {
  echo -e "${TEXT_BOLD}${TEXT_UNDERLINE}${1}${TEXT_RESET}"

  echo -e "${1}" >> $LOGFILE
  echo "===============================================================================" >> $LOGFILE
}

function echo_h2() {
  msg=$1
  prefix=$2

  H2_COUNT=$(($H2_COUNT + 1))
  H3_COUNT=0
  echo
  echo -e "${prefix}${TEXT_UNDERLINE}${H2_COUNT}) ${msg}${TEXT_RESET}"

  echo >> $LOGFILE
  echo -e "${prefix}${H2_COUNT}) ${msg}" >> $LOGFILE
  echo "-------------------------------------------------------------------------------" >> $LOGFILE
}

function echo_h3() {
  msg=$1
  prefix=$2

  H3_COUNT=$(($H3_COUNT + 1))
  echo
  echo -e "${prefix}${TEXT_UNDERLINE}${H2_COUNT}.${H3_COUNT}) ${msg}${TEXT_RESET}"

  echo >> $LOGFILE
  echo -e "${prefix}${H2_COUNT}.${H3_COUNT}) ${msg}" >> $LOGFILE
  echo "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~" >> $LOGFILE
}

function echo_h4() {
  msg=$1
  prefix=$2
  echo -e "${prefix}${TEXT_UNDERLINE}${msg}${TEXT_RESET}"
  echo -e "${prefix}${msg}" >> $LOGFILE
  echo "~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~" >> $LOGFILE
}

function echo_warning() {
  echo -e "${COLOR_RED}$1${TEXT_RESET}"
  echo -e "WARNING: $1" >> $LOGFILE
}

function echo_highlight() {
  echo "${COLOR_CYAN}$1${TEXT_RESET}"
  echo -e "$1" >> $LOGFILE
}

function echo_green() {
  echo "${COLOR_GREEN}$1${TEXT_RESET}"
  echo -e "$1" >> $LOGFILE
}

function echo_blue() {
  echo "${COLOR_BLUE}$1${TEXT_RESET}"
  echo -e "$1" >> $LOGFILE
}

function echo_dim() {
  echo "${TEXT_DIM}$1${TEXT_RESET}"
  echo -e "$1" >> $LOGFILE
}

function echo_reset_dim() {
  echo "${TEXT_RESET}${TEXT_DIM}    $1"
  echo -e "$1" >> $LOGFILE
}

function echo_hr1() {
  echo "===============================================================================" | tee $LOGFILE
}

function echo_hr2() {
  echo "-------------------------------------------------------------------------------" | tee $LOGFILE
}


# Prompt for confirmation to continue
# -----------------------------------------------------------------------------
# Usage:
#  confirm "Do you want to continue" $SAVED_RESPONSE_FROM_LAST_TIME
#  confirm "Do you want to continue"
confirm() {
  prompt=$1
  default=$2
  if [[ "${default}" != "" ]]; then
    read -e -p "${COLOR_YELLOW}${prompt:-Proceed? [y/N]} ${COLOR_MAGENTA}" -i "${default}" response
  else
    read -p "${COLOR_YELLOW}${prompt:-Proceed? [y/N]} ${COLOR_MAGENTA}" response
  fi

  case "$response" in
    [yY][eE][sS]|[yY])
      export ALREADY_CONFIRMED="true"
      true
      ;;
    [nN][oO]|[nN])
      false
      ;;
    *)
      false
      ;;
  esac
}

confirm_default_yes() {
  read -r -p "${COLOR_YELLOW}${1:-Proceed? [Y/n]} ${COLOR_MAGENTA}" response
  case "$response" in
    [yY][eE][sS]|[yY])
      export ALREADY_CONFIRMED="true"
      true
      ;;
    [nN][oO]|[nN])
      export ALREADY_CONFIRMED="true"
      false
      ;;
    *)
      true
      ;;
  esac
}

function prompt_for_number(){
  msg=$1
  varname=$2
  # When override is set, the default provided in $3 will override the saved default
  override=$4

  if [[ -z "${!varname}" || "$override" == "override" ]]; then
    # Use the script default
    default=$3
  else
    # Use the saved default
    default=${!varname}
  fi

  while :; do

    if [[ "${default}" != "" ]]; then
      read -e -p "${COLOR_YELLOW}$msg ${COLOR_MAGENTA}> " -i "${default}" input
    else
      read -p "${COLOR_YELLOW}$msg ${COLOR_MAGENTA}> " input
    fi
    echo -ne "${TEXT_RESET}\033[1K"
    # https://stackoverflow.com/a/13717788
    re='^[1-9][0-9]*$'
    if [[ $input =~ $re ]] ; then
      break
    fi
  done
  printf -v "$varname" "%s" "$input"
}

function prompt_for_secret(){
  msg=$1
  varname=$2
  # When override is set, the default provided in $3 will override the saved default
  reuse_msg=$3

  # Use the saved default
  default=${!varname}

  if [[ "${default}" != "" && "${reuse_msg}" != "" ]]; then
    if ! confirm_default_yes "$reuse_msg [Y/n]"; then
      input=$(/bin/systemd-ask-password "${COLOR_YELLOW}$msg ${COLOR_MAGENTA}> ")
      echo -ne "${TEXT_RESET}\033[1K"
      # https://stackoverflow.com/a/13717788
      printf -v "$varname" "%s" "$input"
    fi
  else
    input=$(/bin/systemd-ask-password "${COLOR_YELLOW}$msg ${COLOR_MAGENTA}> ")
    echo -ne "${TEXT_RESET}\033[1K"
    # https://stackoverflow.com/a/13717788
    printf -v "$varname" "%s" "$input"
  fi
  echo -ne "${TEXT_RESET}\033[1K"
}


function prompt_for_input(){
  msg=$1
  varname=$2
  # When override is set, the default provided in $3 will override the saved default
  override=$4

  if [[ -z "${!varname}" || "$override" == "override" ]]; then
    # Use the script default
    default=$3
  else
    # Use the saved default
    default=${!varname}
  fi

  if [[ "${default}" != "" ]]; then
    read -e -p "${COLOR_YELLOW}$msg ${COLOR_MAGENTA}> " -i "${default}" input
  else
    read -p "${COLOR_YELLOW}$msg ${COLOR_MAGENTA}> " input
  fi
  echo -ne "${TEXT_RESET}\033[1K"
  # https://stackoverflow.com/a/13717788
  printf -v "$varname" "%s" "$input"
}

function check_project_exists(){
  varname=$1
  oc get "project/$varname" > /dev/null 2>&1

  if [ "$?" == "0" ]; then
    true
  else
    false
  fi
}

function prompt_for_confirm() {
  msg=$1
  varname=$2
  if [[ "$varname" != "" ]]; then
    if [[ "${!varname}" == "true" ]]; then
      default="y"
    elif [[ "${!varname}" == "false" ]]; then
      default="n"
    else
      default=""
    fi
  else
    default=""
  fi

  if confirm "${COLOR_YELLOW}$msg ${COLOR_MAGENTA}[y/N]" $default; then
    # Reset colours and clear the current line (\033[1K)
    echo -ne "${TEXT_RESET}\033[1K"
    # Set the variable named "$varname" to "true"
    if [[ "$varname" != "" ]]; then
      printf -v "$varname" "%s" "true"
    fi
    true
  else
    # Reset colours and clear the current line (\033[1K)
    echo -ne "${TEXT_RESET}\033[1K"
    # Set the variable named "$varname" to "false"
    if [[ "$varname" != "" ]]; then
      printf -v "$varname" "%s" "false"
    fi
    false
  fi
}

function prompt_for_confirm_default_yes() {
  msg=$1
  varname=$2
  if confirm_default_yes "${COLOR_YELLOW}$msg ${COLOR_MAGENTA}[Y/n]"; then
    # Reset colours and clear the current line (\033[1K)
    echo -ne "${TEXT_RESET}\033[1K"
    if [[ "$varname" != "" ]]; then
      printf -v "$varname" "%s" "true"
    fi
    true
  else
    # Reset colours and clear the current line (\033[1K)
    echo -ne "${TEXT_RESET}\033[1K"
    if [[ "$varname" != "" ]]; then
      printf -v "$varname" "%s" "false"
    fi
    false
  fi
}

function install_dependencies_ubuntu() {
  # APT package installations
  # python3-pip is required to install additional python packages
  # ansible is required for ansible-galaxy command to be available
  sudo apt install python3-pip ansible

  # Python package installations
  python3 -m pip install ansible junit_xml pymongo xmljson kubernetes==12.0.1 openshift==0.12.1

  # Confirm versions
  python3 --version
  ansible-playbook --version
}

function detect_airgap() {
  oc get ImageContentSourcePolicy ibm-mas-and-dependencies &> /dev/null
  if [[ "$?" == "0" ]]; then
    export AIRGAP_MODE=true
  else
    unset AIRGAP_MODE
  fi
}

# detect_sno function checks the number of nodes in the cluster. If there is only one node, then the cluster is an SNO
# For SNO, we have only one master node and zero worker nodes
# We check for the number of lines the command oc get nodes returns. If it is equal to 2, then the cluster is SNO
# The reason we check for 2 is that the first line is the heading. Following is an example of the output
#                        NAME                           STATUS   ROLES           AGE   VERSION
#                        ip-10-0-141-250.ec2.internal   Ready    master,worker   22h   v1.21.11+5cc9227
# when we run wc -l shell script command, wc gets the word count and -l gets the number of lines.
function detect_sno() {
  sno_num_nodes=$(oc get nodes | wc -l | xargs)
  if [[ "$sno_num_nodes" == "2" ]]; then
    export SNO_MODE=true
  else
    unset SNO_MODE
  fi
}


function ocp_version_check() {
  # TODO: Migrate this into python-devops
  # Check for OCP 4.9, 4.10, & 4.11
  export OCP_VERSION=$(oc get clusterversion version -o jsonpath="{.status.desired.version}")
  if [[ "$OCP_VERSION" =~ ^4\.9\.* ]] || [[ "$OCP_VERSION" =~ ^4\.10\.* ]] || [[ "$OCP_VERSION" =~ ^4\.11\.* ]]; then
    echo
    echo_warning "Warning: OpenShift Container Platform v${OCP_VERSION} detected!"
    echo_warning " - This version is now out of support by Red Hat and ${TEXT_UNDERLINE}not a supported platform for IBM Maximo Application Suite${TEXT_RESET}"
    echo_warning " - The installation of IBM Maximo Application Suite may not proceed, you must upgrade to at least OCP v4.12 before installing/updating/upgrading MAS"
    echo
    echo_warning "For more information refer to the Red Hat OpenShift Container Platform Life Cycle Policy:"
    echo "  ${COLOR_CYAN}${TEXT_UNDERLINE}https://access.redhat.com/support/policy/updates/openshift/${TEXT_RESET}"
    reset_colors
    exit 1
  fi
}

# Calls jinjanate with common arguments. Call jinjanate directly if this does not suit your use case. 
function jinjanate_commmon() {
  local template_path=$1
  local output_path=$2
  local filter_files=$(ls $CLI_DIR/templates/filters/*.py)
  for file in $filter_files; do
    local filter_params="${filter_params} --filters ${file}"
  done
  if [ -n "$output_path" ]; then
    local output_opts="-o ${output_path}"
  fi
  jinjanate --quiet --undefined $filter_params $template_path $output_opts
}

## Install hcl2json if not already installed
## -----------------------------------------------------------------------------
#function ensure_hcl2json_installed() {
#  if ! command -v hcl2json &> /dev/null; then
#    echo "hcl2json not found. Installing..."
#    npm install -g hcl2json
#    if [ $? -ne 0 ]; then
#      echo_warning "Failed to install hcl2json"
#      return 1
#    fi
#    echo "hcl2json installed successfully"
#  fi
#  return 0
#}

# Extract value from Terraform file using dot notation path
# -----------------------------------------------------------------------------
# Usage:
#  get_tf_value "/path/to/file.tf" "locals.workloads.mas-cluster-2-inst2-db2rds.cidrs"
#  get_tf_value "/path/to/file.tf" "locals.cluster.cidrs.workload_external"
#
# Returns the value at the specified path, preserving arrays and complex structures
#function get_tf_value() {
#  local file_path=$1
#  local dot_path=$2
#  echo "in get_tf_value function"
#
##  # Ensure hcl2json is installed
##  if ! ensure_hcl2json_installed; then
##    echo_warning "get_tf_value: hcl2json is required but could not be installed"
##    return 1
##  fi
#
#  if [[ -z "$file_path" ]]; then
#    echo_warning "get_tf_value: file path is required"
#    return 1
#  fi
#
#  if [[ ! -f "$file_path" ]]; then
#    echo_warning "get_tf_value: file does not exist: $file_path"
#    return 1
#  fi
#
#  if [[ -z "$dot_path" ]]; then
#    echo_warning "get_tf_value: dot notation path is required"
#    return 1
#  fi
#
#  # Use Python to parse the HCL file and extract the value
#  python3 << EOF
#import re
#import json
#import sys
#
#def parse_hcl_value(content, start_pos):
#    """Parse a value starting from start_pos, handling strings, arrays, and objects"""
#    content = content[start_pos:].lstrip()
#
#    # Handle string values (quoted)
#    if content.startswith('"'):
#        match = re.match(r'"([^"]*)"', content)
#        if match:
#            return match.group(1), match.end()
#
#    # Handle array values
#    if content.startswith('['):
#        bracket_count = 0
#        in_string = False
#        escape_next = False
#        end_pos = 0
#
#        for i, char in enumerate(content):
#            if escape_next:
#                escape_next = False
#                continue
#            if char == '\\':
#                escape_next = True
#                continue
#            if char == '"' and not escape_next:
#                in_string = not in_string
#            if not in_string:
#                if char == '[':
#                    bracket_count += 1
#                elif char == ']':
#                    bracket_count -= 1
#                    if bracket_count == 0:
#                        end_pos = i + 1
#                        break
#
#        if end_pos > 0:
#            array_str = content[:end_pos]
#            return array_str, end_pos
#
#    # Handle object values
#    if content.startswith('{'):
#        brace_count = 0
#        in_string = False
#        escape_next = False
#        end_pos = 0
#
#        for i, char in enumerate(content):
#            if escape_next:
#                escape_next = False
#                continue
#            if char == '\\':
#                escape_next = True
#                continue
#            if char == '"' and not escape_next:
#                in_string = not in_string
#            if not in_string:
#                if char == '{':
#                    brace_count += 1
#                elif char == '}':
#                    brace_count -= 1
#                    if brace_count == 0:
#                        end_pos = i + 1
#                        break
#
#        if end_pos > 0:
#            obj_str = content[:end_pos]
#            return obj_str, end_pos
#
#    # Handle simple unquoted values (numbers, booleans, identifiers)
#    match = re.match(r'([^\s\n,\]\}]+)', content)
#    if match:
#        return match.group(1), match.end()
#
#    return None, 0
#
#def extract_tf_value(file_path, dot_path):
#    """Extract value from Terraform file using dot notation"""
#    try:
#        with open(file_path, 'r') as f:
#            content = f.read()
#
#        # Split the path into components
#        path_parts = dot_path.split('.')
#
#        # Start searching from the beginning
#        current_content = content
#
#        for i, part in enumerate(path_parts):
#            # Create a regex pattern to find the key
#            # Handle both 'key =' and '"key" :' formats
#            pattern = rf'(?:^|\n)\s*(?:"{re.escape(part)}"|{re.escape(part)})\s*[=:]\s*'
#
#            match = re.search(pattern, current_content, re.MULTILINE)
#
#            if not match:
#                print(f"Error: Could not find '{part}' in path", file=sys.stderr)
#                return None
#
#            # Get the position after the '=' or ':'
#            start_pos = match.end()
#
#            # If this is the last part of the path, extract and return the value
#            if i == len(path_parts) - 1:
#                value, _ = parse_hcl_value(current_content, start_pos)
#                if value:
#                    # Clean up the value for output
#                    value = value.strip()
#                    print(value)
#                    return value
#                else:
#                    print(f"Error: Could not parse value for '{part}'", file=sys.stderr)
#                    return None
#            else:
#                # For intermediate parts, we need to find the nested structure
#                value, end_offset = parse_hcl_value(current_content, start_pos)
#                if value and (value.startswith('{') or value.startswith('[')):
#                    # Continue searching within this structure
#                    current_content = value
#                else:
#                    print(f"Error: Expected object or array at '{part}'", file=sys.stderr)
#                    return None
#
#        return None
#
#    except Exception as e:
#        print(f"Error: {str(e)}", file=sys.stderr)
#        return None
#
## Main execution
#result = extract_tf_value("$file_path", "$dot_path")
#if result is None:
#    sys.exit(1)
#EOF
#
#  return $?
#}


#!/usr/bin/env bash

function get_tf_value() {
    local FILE="$1"
    local DOTPATH="$2"

    if [[ -z "$FILE" || -z "$DOTPATH" ]]; then
        echo "Usage: get_tf_value <file.tf> '<dot.path>'" >&2
        return 1
    fi

    echo "$FILE" >&2
    echo "$DOTPATH" >&2
    # Use the same python interpreter everywhere
    local PYTHON_BIN
    PYTHON_BIN=$(command -v python3)

    if [[ -z "$PYTHON_BIN" ]]; then
        echo "Error: python3 not found" >&2
        return 1
    fi

    # Install python-hcl2 if missing
    if ! $PYTHON_BIN -c "import hcl2" 2>/dev/null; then
        echo "python-hcl2 not found. Installing..." >&2
        $PYTHON_BIN -m pip install python-hcl2 >/dev/null
    fi

    # Run Python and print ONLY the value
    $PYTHON_BIN <<EOF
import hcl2
import re
import sys

file_path = """$FILE"""
dot_path = """$DOTPATH"""   # <- triple-quoted to avoid ANY shell quoting issues

def load_hcl(path):
    with open(path, "r") as f:
        return hcl2.load(f)

def unwrap_singleton_lists(obj):
    if isinstance(obj, list) and len(obj) == 1:
        return unwrap_singleton_lists(obj[0])
    if isinstance(obj, dict):
        return {k: unwrap_singleton_lists(v) for k, v in obj.items()}
    return obj

def resolve_path(obj, path):
    # tokens: key, [0], ["key-with-dash"]
    tokens = re.findall(r'\w+|\[\d+\]|\[".*?"\]', path)

    value = obj
    for t in tokens:
        # list index
        if t.startswith("[") and t.endswith("]") and t[1:-1].isdigit():
            value = value[int(t[1:-1])]
        # quoted key
        elif t.startswith('["') and t.endswith('"]'):
            value = value[t[2:-2]]
        else:
            value = value[t]
    return value

data = unwrap_singleton_lists(load_hcl(file_path))

try:
    result = resolve_path(data, dot_path)
    print(result)
except Exception as e:
    print(f"Error: {e}", file=sys.stderr)
    sys.exit(1)
EOF
}



# Go to GITOPS_CLUSTER_DIR
# check
# if backend.tf is there or not if not then create
# if terraform.tfvars is there or not if not then create
# if variables.tf is there or not if not then create
# if main.tf is there or not if not then create
# if provider.tf is there or not if not then create
function create_common_files() {
  local cluster_dir=$1
  
  if [[ -z "$cluster_dir" ]]; then
    echo_warning "create_common_files: cluster directory path is required"
    return 1
  fi
  
  if [[ ! -d "$cluster_dir" ]]; then
    echo_warning "create_common_files: directory does not exist: $cluster_dir"
    return 1
  fi
  
  # Handle backend.tf with template
  if [[ ! -f "$cluster_dir/backend.tf" ]]; then
    echo "  Creating backend.tf from template"
    jinjanate_commmon "$CLI_DIR/templates/gitops/appset-configs/cluster/instance/ibm-iac-backendTF.yaml.j2" "$cluster_dir/backend.tf.json"
  else
    echo "  File already exists: backend.tf"
  fi
  
  # Handle provider.tf with template
  if [[ ! -f "$cluster_dir/provider.tf" ]]; then
    echo "  Creating provider.tf from template"
    jinjanate_commmon "$CLI_DIR/templates/gitops/appset-configs/cluster/instance/ibm-iac-providerTF.yaml.j2" "$cluster_dir/provider.tf"
  else
    echo "  File already exists: provider.tf"
  fi
  
  # Create other empty files if they don't exist
  local empty_tf_files=("terraform.tfvars" "variables.tf" "main.tf")
  
  for file in "${empty_tf_files[@]}"; do
    if [[ ! -f "$cluster_dir/$file" ]]; then
      echo "  Creating empty file: $file"
      touch "$cluster_dir/$file"
    else
      echo "  File already exists: $file"
    fi
  done
}